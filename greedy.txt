int comparar_por_riesgo_desc(const void *a, const void *b) {
    // Convertimos los punteros genéricos a punteros de struct persona
    const persona *p1 = (const persona *)a;
    const persona *p2 = (const persona *)b;

    // Criterio Voraz: Queremos que el riesgo más alto (p2) vaya primero.
    if (p1->riesgo_inicial < p2->riesgo_inicial) {
        return 1;  // p1 va DESPUÉS de p2
    } else if (p1->riesgo_inicial > p2->riesgo_inicial) {
        return -1; // p1 va ANTES de p2
    } else {
        return 0;  // Riesgos iguales
    }
}

void minimizar_riesgo_greedy(sistema *s, int terr_id, double riesgo_target) {
    
    // Verificaciones básicas
    if (terr_id < 0 || terr_id >= s->numterritorios) {
        printf("Error: ID de territorio invalido.\n");
        return;
    }

    persona *poblacion = s->territorios[terr_id].personas;
    int M = s->territorios[terr_id].M;
    double riesgo_total = 0.0; //Variable que usaremos para la cota máxima, para calcular el límite del riesgo total de cada territorio asi para que cuando se ingrese un riesto objetivo de entrada superior al riesgo total acumulado, se transforme en un target alcanzable

    printf("\n--- SUBPROBLEMA 4: MINIMIZACION DEL RIESGO (O(N log N)) ---\n");
    printf("Territorio a analizar: %d | Objetivo de Riesgo: %.2f\n", terr_id, riesgo_target);

    for(int i = 0; i < M; i++) {
        riesgo_total += poblacion[i].riesgo_inicial; // Suma de todos los riesgos
    }

    // 2. VALIDACIÓN DE ENTRADA (Asegurar que el target es alcanzable)
    if (riesgo_target > riesgo_total) {
        printf("ADVERTENCIA: El objetivo %.2f es inalcanzable.\n", riesgo_target);
        printf("Estableciendo el objetivo al maximo riesgo posible: %.2f\n", riesgo_total);
        riesgo_target = riesgo_total;
    }

    // --- FASE I: Ordenamiento (El costo O(N log N)) ---
    // Ordenamos la población in-place por riesgo_inicial de forma descendente.
    qsort(poblacion, M, sizeof(persona), comparar_por_riesgo_desc); 

    // --- FASE II: Selección Voraz (Recorrido O(M)) ---
    double riesgo_acumulado = 0.0;
    int k_aislados = 0;
    
    // Recorremos la lista ya ordenada, tomando al mas riesgoso en cada paso.
    for (int i = 0; i < M; i++) {
        
        // El algoritmo voraz se detiene en cuanto alcanza la meta
        if (riesgo_acumulado >= riesgo_target) {
            break;
        }
        
        // Decisión Voraz: Sumar el riesgo del individuo actual (el más alto restante)
        riesgo_acumulado += poblacion[i].riesgo_inicial;
        k_aislados++;
        
        printf("Aislando ID %d (Riesgo %.4f) -> Acumulado: %.4f\n", poblacion[i].id, poblacion[i].riesgo_inicial, riesgo_acumulado);
    }

    printf("Se aislaron %d personas (el subconjunto minimo) para contener un riesgo total de %.2f.\n", k_aislados, riesgo_acumulado);
}